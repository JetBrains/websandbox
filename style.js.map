{"version":3,"file":"style.js","mappings":";;;;;;;;;;;;;;;;;;;AAA0D;AACnD;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAS;AACnC;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oFAAoF,IAAI,GAAG,OAAO;AAClG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,uBAAuB,4DAAc;AACrC;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;;ACvO1B,0BAA0B;AACnB;AACP;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACO;AACP;AACA;AACO;AACP;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,YAAY;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrCsC;AACtC;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,kCAAkC,mDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4BAA4B;AAClF;AACA;AACA,kDAAkD,qEAAmB,CAAC;AACtE;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA;AACA;AACA,2EAA2E,gBAAgB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAyC;AA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","sources":["webpack://@jetbrains/websandbox/./lib/connection.ts","webpack://@jetbrains/websandbox/./lib/object-path.ts","webpack://@jetbrains/websandbox/./lib/websandbox.ts","webpack://@jetbrains/websandbox/./lib/frame.ts","webpack://@jetbrains/websandbox/webpack/bootstrap","webpack://@jetbrains/websandbox/webpack/runtime/compat get default export","webpack://@jetbrains/websandbox/webpack/runtime/define property getters","webpack://@jetbrains/websandbox/webpack/runtime/hasOwnProperty shorthand","webpack://@jetbrains/websandbox/webpack/runtime/make namespace object","webpack://@jetbrains/websandbox/./examples/style/style.js"],"sourcesContent":["import { propertyByPath, splitPath } from \"./object-path\";\nexport const TYPE_MESSAGE = 'message';\nexport const TYPE_RESPONSE = 'response';\nexport const TYPE_SET_INTERFACE = 'set-interface';\nexport const TYPE_SERVICE_MESSAGE = 'service-message';\n// @ts-expect-error this is IE11 obsolete check. It is not typed\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\nconst defaultOptions = {\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\n    //but base URL of iframe's src\n    allowedSenderOrigin: undefined\n};\nclass Connection {\n    constructor(postMessage, registerOnMessageListener, options = {}) {\n        this.remote = {};\n        this.serviceMethods = {};\n        this.localApi = {};\n        this.callbacks = {};\n        this._resolveRemoteMethodsPromise = null;\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\n        //Random number between 0 and 100000\n        this.incrementalID = Math.floor(Math.random() * 100000);\n        this.postMessage = postMessage;\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\n            this._resolveRemoteMethodsPromise = resolve;\n        });\n        registerOnMessageListener((e) => this.onMessageListener(e));\n    }\n    /**\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\n       * @param e - onMessage event\n       */\n    onMessageListener(e) {\n        const data = e.data;\n        const { allowedSenderOrigin } = this.options;\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\n            return;\n        }\n        if (data.type === TYPE_RESPONSE) {\n            this.popCallback(data.callId, data.success, data.result);\n        }\n        else if (data.type === TYPE_MESSAGE) {\n            this\n                .callLocalApi(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n        else if (data.type === TYPE_SET_INTERFACE) {\n            this.setInterface(data.apiMethods);\n            this.responseOtherSide(data.callId);\n        }\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\n            this\n                .callLocalServiceMethod(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n    }\n    postMessageToOtherSide(dataToPost) {\n        this.postMessage(dataToPost, '*');\n    }\n    /**\n       * Sets remote interface methods\n       * @param remote - hash with keys of remote API methods. Values is ignored\n       */\n    setInterface(remoteMethods) {\n        var _a;\n        this.remote = {};\n        remoteMethods.forEach((key) => {\n            // If key is nested, we need to create nested structure\n            const parts = splitPath(key);\n            let current = this.remote;\n            for (let i = 0; i < parts.length - 1; i++) {\n                const part = parts[i];\n                if (!current[part] || typeof current[part] !== 'object') {\n                    current[part] = {};\n                }\n                current = current[part];\n            }\n            current[parts[parts.length - 1]] = this.createMethodWrapper(key);\n        });\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    getMethodsFromInterface(api) {\n        return Object.keys(api).reduce((acc, key) => {\n            if (typeof api[key] === 'object') {\n                acc.push(...this.getMethodsFromInterface(api[key]).map(subKey => `${key}.${subKey}`));\n            }\n            else {\n                acc.push(key);\n            }\n            return acc;\n        }, []);\n    }\n    setLocalApi(api) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                apiMethods: this.getMethodsFromInterface(api),\n                type: TYPE_SET_INTERFACE\n            });\n        }).then(() => this.localApi = api);\n    }\n    setServiceMethods(api) {\n        this.serviceMethods = api;\n    }\n    /**\n       * Calls local method\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>|string}\n       */\n    callLocalApi(methodName, args) {\n        const method = propertyByPath(this.localApi, methodName);\n        if (!method) {\n            throw new Error(`Local method \"${methodName}\" is not registered`);\n        }\n        return Promise.resolve(method.call(this, ...args));\n    }\n    /**\n       * Calls local method registered as \"service method\"\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>}\n       */\n    callLocalServiceMethod(methodName, args) {\n        const method = propertyByPath(this.serviceMethods, methodName);\n        if (!method) {\n            throw new Error(`Service method ${methodName} is not registered`);\n        }\n        return Promise.resolve(method.call(this, ...args));\n    }\n    /**\n       * Wraps remote method with callback storing code\n       * @param methodName - method to wrap\n       * @returns {Function} - function to call as remote API interface\n       */\n    createMethodWrapper(methodName) {\n        return (...args) => {\n            return this.callRemoteMethod(methodName, ...args);\n        };\n    }\n    /**\n       * Calls other side with arguments provided\n       * @param id\n       * @param methodName\n       * @param args\n       */\n    callRemoteMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Calls remote service method\n       * @param methodName\n       * @param args\n       * @returns {*}\n       */\n    callRemoteServiceMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_SERVICE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Respond to remote call\n       * @param id - remote call ID\n       * @param result - result to pass to calling function\n       */\n    responseOtherSide(id, result, success = true) {\n        if (result instanceof Error) {\n            // Error could be non-serializable, so we copy properties manually\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\n                acc[it] = result[it];\n                return acc;\n            }, {});\n        }\n        const doPost = () => this.postMessage({\n            callId: id,\n            type: TYPE_RESPONSE,\n            success,\n            result\n        }, '*');\n        try {\n            doPost();\n        }\n        catch (err) {\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\n            if (err instanceof DOMException) {\n                result = JSON.parse(JSON.stringify(result));\n                doPost();\n            }\n        }\n    }\n    /*\n       * Stores callbacks to call later when remote call will be answered\n       */\n    registerCallback(successCallback, failureCallback) {\n        const id = (++this.incrementalID).toString();\n        this.callbacks[id] = { successCallback, failureCallback };\n        return id;\n    }\n    /**\n       * Calls and delete stored callback\n       * @param id - call id\n       * @param success - was call successful\n       * @param result - result of remote call\n       */\n    popCallback(id, success, result) {\n        if (success) {\n            this.callbacks[id].successCallback(result);\n        }\n        else {\n            this.callbacks[id].failureCallback(result);\n        }\n        delete this.callbacks[id];\n    }\n}\nexport default Connection;\n","const PATH_REG = /([.[\\]:;'\"\\s])/;\nexport function escapePathPart(pathPart) {\n    if (!PATH_REG.test(pathPart)) {\n        return pathPart;\n    }\n    const escaped = pathPart.replace(new RegExp(PATH_REG.source, 'g'), '\\\\$1');\n    return `[\"${escaped}\"]`;\n}\nexport function unescapePathPart(pathPart) {\n    return pathPart.replace(/^\\[\"/, '').replace(/\"]$/, '').replace(/\\\\/, '');\n}\nexport function splitPath(path) {\n    const result = [];\n    let lastEnd = 0;\n    for (let i = 0; i < path.length; i++) {\n        const char = path[i];\n        if (PATH_REG.test(char) && path[i - 1] !== '\\\\') {\n            result.push(path.substring(lastEnd, i));\n            lastEnd = i + 1;\n        }\n    }\n    result.push(path.substring(lastEnd, path.length));\n    return result.filter(pathPart => !!pathPart).map(pathPart => pathPart.replace(/\\\\/g, ''));\n}\n/**\n * Extracts object property value by given path. Supports nested and array values: 'foo[0].bar'\n * @param {Object} object source object\n * @param {string} path path to value\n * @return {any | null} value by given path\n * */\nexport function propertyByPath(object, path) {\n    return splitPath(path).reduce((acc, pathPart) => {\n        if (acc) {\n            return acc[pathPart];\n        }\n        return null;\n    }, object);\n}\n","import Connection from './connection';\n// @ts-expect-error loader-based input\nimport CompiledFrameScript from 'compile-code-loader!./frame.ts';\nexport const BaseOptions = {\n    frameContainer: 'body',\n    frameClassName: 'websandbox__frame',\n    frameSrc: null,\n    frameContent: `\n<!DOCTYPE html>\n<html>\n<head><meta charset=\"UTF-8\"></head>\n<body></body>\n</html>\n  `,\n    codeToRunBeforeInit: null,\n    initialStyles: null,\n    baseUrl: null,\n    allowPointerLock: false,\n    allowFullScreen: false,\n    sandboxAdditionalAttributes: ''\n};\nclass Websandbox {\n    /**\n     * Creates sandbox instancea\n     * @param localApi Api of this side. Will be available for sandboxed code as remoteApi\n     * @param options Options of created sandbox\n     */\n    static create(localApi, options = {}) {\n        return new Websandbox(localApi, options);\n    }\n    /**\n     * {Constructor}\n     * @param localApi\n     * @param options\n     */\n    constructor(localApi, options) {\n        this.connection = null;\n        this.removeMessageListener = () => { };\n        this.validateOptions(options);\n        this.options = Object.assign(Object.assign({}, BaseOptions), options);\n        this.iframe = this.createIframe();\n        this.promise = new Promise(resolve => {\n            this.connection = new Connection(this.iframe.contentWindow.postMessage.bind(this.iframe.contentWindow), listener => {\n                const sourceCheckListener = (event) => {\n                    if (event.source !== this.iframe.contentWindow) {\n                        return;\n                    }\n                    return listener(event);\n                };\n                window.addEventListener('message', sourceCheckListener);\n                this.removeMessageListener = () => window.removeEventListener('message', sourceCheckListener);\n            }, { allowedSenderOrigin: 'null' });\n            this.connection.setServiceMethods({\n                iframeInitialized: () => {\n                    return this.connection\n                        .setLocalApi(localApi)\n                        .then(() => resolve(this));\n                }\n            });\n        });\n    }\n    validateOptions(options) {\n        var _a;\n        if (options.frameSrc && (options.frameContent || options.initialStyles || options.baseUrl || options.codeToRunBeforeInit)) {\n            throw new Error('You can not set both \"frameSrc\" and any of frameContent,initialStyles,baseUrl,codeToRunBeforeInit options');\n        }\n        if ('frameContent' in options && !((_a = options.frameContent) === null || _a === void 0 ? void 0 : _a.includes('<head>'))) {\n            throw new Error('Websandbox: iFrame content must have \"<head>\" tag.');\n        }\n    }\n    _prepareFrameContent(options) {\n        var _a, _b, _c;\n        let frameContent = (_a = options.frameContent) !== null && _a !== void 0 ? _a : '';\n        if (options.codeToRunBeforeInit) {\n            frameContent = (_b = frameContent\n                .replace('<head>', `<head>\\n<script>${options.codeToRunBeforeInit}</script>`)) !== null && _b !== void 0 ? _b : '';\n        }\n        frameContent = (_c = frameContent\n            .replace('<head>', `<head>\\n<script>${CompiledFrameScript}</script>`)) !== null && _c !== void 0 ? _c : '';\n        if (options.initialStyles) {\n            frameContent = frameContent\n                .replace('</head>', `<style>${options.initialStyles}</style>\\n</head>`);\n        }\n        if (options.baseUrl) {\n            frameContent = frameContent\n                .replace('<head>', `<head>\\n<base target=\"_parent\" href=\"${options.baseUrl}\"/>`);\n        }\n        return frameContent;\n    }\n    createIframe() {\n        var _a;\n        const containerSelector = this.options.frameContainer;\n        const container = typeof containerSelector === 'string'\n            ? document.querySelector(containerSelector)\n            : containerSelector;\n        if (!container) {\n            throw new Error('Websandbox: Cannot find container for sandbox ' + container);\n        }\n        const frame = document.createElement('iframe');\n        frame.sandbox = `allow-scripts ${this.options.sandboxAdditionalAttributes}`;\n        frame.allow = `${this.options.allowAdditionalAttributes}`;\n        frame.className = (_a = this.options.frameClassName) !== null && _a !== void 0 ? _a : '';\n        if (this.options.allowFullScreen) {\n            frame.allowFullscreen = true;\n        }\n        if (this.options.frameSrc) {\n            frame.src = this.options.frameSrc;\n            container.appendChild(frame);\n            return frame;\n        }\n        frame.setAttribute('srcdoc', this._prepareFrameContent(this.options));\n        container.appendChild(frame);\n        return frame;\n    }\n    destroy() {\n        this.iframe.remove();\n        this.removeMessageListener();\n    }\n    _runCode(code) {\n        return this.connection.callRemoteServiceMethod('runCode', code);\n    }\n    _runFunction(fn) {\n        return this._runCode(`(${fn.toString()})()`);\n    }\n    run(codeOrFunction) {\n        if (codeOrFunction.name) {\n            return this._runFunction(codeOrFunction);\n        }\n        return this._runCode(codeOrFunction);\n    }\n    importScript(path) {\n        return this.connection.callRemoteServiceMethod('importScript', path);\n    }\n    injectStyle(style) {\n        return this.connection.callRemoteServiceMethod('injectStyle', style);\n    }\n}\nexport default Websandbox;\n","module.exports = \"/******/ (() => { // webpackBootstrap\\n/******/ \\t\\\"use strict\\\";\\n/******/ \\tvar __webpack_modules__ = ({\\n\\n/***/ \\\"./lib/connection.ts\\\":\\n/*!***************************!*\\\\\\n  !*** ./lib/connection.ts ***!\\n  \\\\***************************/\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   TYPE_MESSAGE: () => (/* binding */ TYPE_MESSAGE),\\n/* harmony export */   TYPE_RESPONSE: () => (/* binding */ TYPE_RESPONSE),\\n/* harmony export */   TYPE_SERVICE_MESSAGE: () => (/* binding */ TYPE_SERVICE_MESSAGE),\\n/* harmony export */   TYPE_SET_INTERFACE: () => (/* binding */ TYPE_SET_INTERFACE),\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _object_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object-path */ \\\"./lib/object-path.ts\\\");\\n\\nconst TYPE_MESSAGE = 'message';\\nconst TYPE_RESPONSE = 'response';\\nconst TYPE_SET_INTERFACE = 'set-interface';\\nconst TYPE_SERVICE_MESSAGE = 'service-message';\\n// @ts-expect-error this is IE11 obsolete check. It is not typed\\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\\nconst defaultOptions = {\\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\\n    //but base URL of iframe's src\\n    allowedSenderOrigin: undefined\\n};\\nclass Connection {\\n    constructor(postMessage, registerOnMessageListener, options = {}) {\\n        this.remote = {};\\n        this.serviceMethods = {};\\n        this.localApi = {};\\n        this.callbacks = {};\\n        this._resolveRemoteMethodsPromise = null;\\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\\n        //Random number between 0 and 100000\\n        this.incrementalID = Math.floor(Math.random() * 100000);\\n        this.postMessage = postMessage;\\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\\n            this._resolveRemoteMethodsPromise = resolve;\\n        });\\n        registerOnMessageListener((e) => this.onMessageListener(e));\\n    }\\n    /**\\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\\n       * @param e - onMessage event\\n       */\\n    onMessageListener(e) {\\n        const data = e.data;\\n        const { allowedSenderOrigin } = this.options;\\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\\n            return;\\n        }\\n        if (data.type === TYPE_RESPONSE) {\\n            this.popCallback(data.callId, data.success, data.result);\\n        }\\n        else if (data.type === TYPE_MESSAGE) {\\n            this\\n                .callLocalApi(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n        else if (data.type === TYPE_SET_INTERFACE) {\\n            this.setInterface(data.apiMethods);\\n            this.responseOtherSide(data.callId);\\n        }\\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\\n            this\\n                .callLocalServiceMethod(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n    }\\n    postMessageToOtherSide(dataToPost) {\\n        this.postMessage(dataToPost, '*');\\n    }\\n    /**\\n       * Sets remote interface methods\\n       * @param remote - hash with keys of remote API methods. Values is ignored\\n       */\\n    setInterface(remoteMethods) {\\n        var _a;\\n        this.remote = {};\\n        remoteMethods.forEach((key) => {\\n            // If key is nested, we need to create nested structure\\n            const parts = (0,_object_path__WEBPACK_IMPORTED_MODULE_0__.splitPath)(key);\\n            let current = this.remote;\\n            for (let i = 0; i < parts.length - 1; i++) {\\n                const part = parts[i];\\n                if (!current[part] || typeof current[part] !== 'object') {\\n                    current[part] = {};\\n                }\\n                current = current[part];\\n            }\\n            current[parts[parts.length - 1]] = this.createMethodWrapper(key);\\n        });\\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\\n    }\\n    getMethodsFromInterface(api) {\\n        return Object.keys(api).reduce((acc, key) => {\\n            if (typeof api[key] === 'object') {\\n                acc.push(...this.getMethodsFromInterface(api[key]).map(subKey => `${key}.${subKey}`));\\n            }\\n            else {\\n                acc.push(key);\\n            }\\n            return acc;\\n        }, []);\\n    }\\n    setLocalApi(api) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                apiMethods: this.getMethodsFromInterface(api),\\n                type: TYPE_SET_INTERFACE\\n            });\\n        }).then(() => this.localApi = api);\\n    }\\n    setServiceMethods(api) {\\n        this.serviceMethods = api;\\n    }\\n    /**\\n       * Calls local method\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>|string}\\n       */\\n    callLocalApi(methodName, args) {\\n        const method = (0,_object_path__WEBPACK_IMPORTED_MODULE_0__.propertyByPath)(this.localApi, methodName);\\n        if (!method) {\\n            throw new Error(`Local method \\\"${methodName}\\\" is not registered`);\\n        }\\n        return Promise.resolve(method.call(this, ...args));\\n    }\\n    /**\\n       * Calls local method registered as \\\"service method\\\"\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>}\\n       */\\n    callLocalServiceMethod(methodName, args) {\\n        const method = (0,_object_path__WEBPACK_IMPORTED_MODULE_0__.propertyByPath)(this.serviceMethods, methodName);\\n        if (!method) {\\n            throw new Error(`Service method ${methodName} is not registered`);\\n        }\\n        return Promise.resolve(method.call(this, ...args));\\n    }\\n    /**\\n       * Wraps remote method with callback storing code\\n       * @param methodName - method to wrap\\n       * @returns {Function} - function to call as remote API interface\\n       */\\n    createMethodWrapper(methodName) {\\n        return (...args) => {\\n            return this.callRemoteMethod(methodName, ...args);\\n        };\\n    }\\n    /**\\n       * Calls other side with arguments provided\\n       * @param id\\n       * @param methodName\\n       * @param args\\n       */\\n    callRemoteMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Calls remote service method\\n       * @param methodName\\n       * @param args\\n       * @returns {*}\\n       */\\n    callRemoteServiceMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_SERVICE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Respond to remote call\\n       * @param id - remote call ID\\n       * @param result - result to pass to calling function\\n       */\\n    responseOtherSide(id, result, success = true) {\\n        if (result instanceof Error) {\\n            // Error could be non-serializable, so we copy properties manually\\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\\n                acc[it] = result[it];\\n                return acc;\\n            }, {});\\n        }\\n        const doPost = () => this.postMessage({\\n            callId: id,\\n            type: TYPE_RESPONSE,\\n            success,\\n            result\\n        }, '*');\\n        try {\\n            doPost();\\n        }\\n        catch (err) {\\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\\n            if (err instanceof DOMException) {\\n                result = JSON.parse(JSON.stringify(result));\\n                doPost();\\n            }\\n        }\\n    }\\n    /*\\n       * Stores callbacks to call later when remote call will be answered\\n       */\\n    registerCallback(successCallback, failureCallback) {\\n        const id = (++this.incrementalID).toString();\\n        this.callbacks[id] = { successCallback, failureCallback };\\n        return id;\\n    }\\n    /**\\n       * Calls and delete stored callback\\n       * @param id - call id\\n       * @param success - was call successful\\n       * @param result - result of remote call\\n       */\\n    popCallback(id, success, result) {\\n        if (success) {\\n            this.callbacks[id].successCallback(result);\\n        }\\n        else {\\n            this.callbacks[id].failureCallback(result);\\n        }\\n        delete this.callbacks[id];\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Connection);\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./lib/object-path.ts\\\":\\n/*!****************************!*\\\\\\n  !*** ./lib/object-path.ts ***!\\n  \\\\****************************/\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   escapePathPart: () => (/* binding */ escapePathPart),\\n/* harmony export */   propertyByPath: () => (/* binding */ propertyByPath),\\n/* harmony export */   splitPath: () => (/* binding */ splitPath),\\n/* harmony export */   unescapePathPart: () => (/* binding */ unescapePathPart)\\n/* harmony export */ });\\nconst PATH_REG = /([.[\\\\]:;'\\\"\\\\s])/;\\nfunction escapePathPart(pathPart) {\\n    if (!PATH_REG.test(pathPart)) {\\n        return pathPart;\\n    }\\n    const escaped = pathPart.replace(new RegExp(PATH_REG.source, 'g'), '\\\\\\\\$1');\\n    return `[\\\"${escaped}\\\"]`;\\n}\\nfunction unescapePathPart(pathPart) {\\n    return pathPart.replace(/^\\\\[\\\"/, '').replace(/\\\"]$/, '').replace(/\\\\\\\\/, '');\\n}\\nfunction splitPath(path) {\\n    const result = [];\\n    let lastEnd = 0;\\n    for (let i = 0; i < path.length; i++) {\\n        const char = path[i];\\n        if (PATH_REG.test(char) && path[i - 1] !== '\\\\\\\\') {\\n            result.push(path.substring(lastEnd, i));\\n            lastEnd = i + 1;\\n        }\\n    }\\n    result.push(path.substring(lastEnd, path.length));\\n    return result.filter(pathPart => !!pathPart).map(pathPart => pathPart.replace(/\\\\\\\\/g, ''));\\n}\\n/**\\n * Extracts object property value by given path. Supports nested and array values: 'foo[0].bar'\\n * @param {Object} object source object\\n * @param {string} path path to value\\n * @return {any | null} value by given path\\n * */\\nfunction propertyByPath(object, path) {\\n    return splitPath(path).reduce((acc, pathPart) => {\\n        if (acc) {\\n            return acc[pathPart];\\n        }\\n        return null;\\n    }, object);\\n}\\n\\n\\n/***/ })\\n\\n/******/ \\t});\\n/************************************************************************/\\n/******/ \\t// The module cache\\n/******/ \\tvar __webpack_module_cache__ = {};\\n/******/ \\t\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\t\\tif (cachedModule !== undefined) {\\n/******/ \\t\\t\\treturn cachedModule.exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t\\t// no module.id needed\\n/******/ \\t\\t\\t// no module.loaded needed\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/ \\t\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n/******/ \\t\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t/* webpack/runtime/define property getters */\\n/******/ \\t(() => {\\n/******/ \\t\\t// define getter functions for harmony exports\\n/******/ \\t\\t__webpack_require__.d = (exports, definition) => {\\n/******/ \\t\\t\\tfor(var key in definition) {\\n/******/ \\t\\t\\t\\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n/******/ \\t\\t\\t\\t\\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\\n/******/ \\t\\t\\t\\t}\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/hasOwnProperty shorthand */\\n/******/ \\t(() => {\\n/******/ \\t\\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/make namespace object */\\n/******/ \\t(() => {\\n/******/ \\t\\t// define __esModule on exports\\n/******/ \\t\\t__webpack_require__.r = (exports) => {\\n/******/ \\t\\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/************************************************************************/\\nvar __webpack_exports__ = {};\\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.\\n(() => {\\n/*!*****************************************************************************!*\\\\\\n  !*** ./node_modules/ts-loader/index.js??ruleSet[1].rules[0]!./lib/frame.ts ***!\\n  \\\\*****************************************************************************/\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connection */ \\\"./lib/connection.ts\\\");\\n\\nclass Frame {\\n    constructor() {\\n        this.connection = new _connection__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](window.parent.postMessage.bind(window.parent), listener => {\\n            const sourceCheckListener = (event) => {\\n                if (event.source !== window.parent) {\\n                    return;\\n                }\\n                return listener(event);\\n            };\\n            window.addEventListener('message', sourceCheckListener);\\n        });\\n        this.connection.setServiceMethods({\\n            runCode: (code) => this.runCode(code),\\n            importScript: (path) => this.importScript(path),\\n            injectStyle: (style) => this.injectStyle(style),\\n            importStyle: (path) => this.importStyle(path)\\n        });\\n        this.connection.callRemoteServiceMethod('iframeInitialized');\\n    }\\n    /**\\n       * Creates script tag with passed code and attaches it. Runs synchronous\\n       * @param code\\n       */\\n    runCode(code) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.innerHTML = code;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n    }\\n    importScript(scriptUrl) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.src = scriptUrl;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n        return new Promise(resolve => scriptTag.onload = () => resolve());\\n    }\\n    injectStyle(style) {\\n        const styleTag = document.createElement('style');\\n        styleTag.innerHTML = style;\\n        document.getElementsByTagName('head')[0].appendChild(styleTag);\\n    }\\n    importStyle(styleUrl) {\\n        const linkTag = document.createElement('link');\\n        linkTag.rel = 'stylesheet';\\n        linkTag.href = styleUrl;\\n        document.getElementsByTagName('head')[0].appendChild(linkTag);\\n    }\\n}\\n// @ts-expect-error we explicitly export library to global namespace because\\nconst Websandbox = window.Websandbox || new Frame();\\n// @ts-expect-error we explicitly export library to global namespace because\\n// Webpack won't do it for us when this file is loaded via code-loader\\nwindow.Websandbox = Websandbox;\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Websandbox);\\n\\n})();\\n\\n/******/ })()\\n;\\n//# sourceMappingURL=compile-loader-file-name.js.map\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable no-console */\nimport Sandbox from '../../lib/websandbox';\n\nconst sandbox = Sandbox.create({});\nsandbox.promise\n    .then(() => {\n        console.log('Sandbox is created. Trying to inject styles inside');\n\n        return sandbox.injectStyle(`\n            html, body {\n                background-color: blue;\n            }\n        `);\n    })\n    .then(() => console.log('Style has been injected if iframe is blue'));\n\n\n"],"names":[],"sourceRoot":""}