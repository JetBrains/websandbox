{"version":3,"file":"simple.js","mappings":";;;;;;;;;AAAA,oCAAoC,+CAA+C,yCAAyC,0NAA0N,+CAA+C,mEAAmE,sbAAsb,EAAE,iCAAiC,mCAAmC,6CAA6C,iDAAiD,4IAA4I,0BAA0B,6JAA6J,oBAAoB,sEAAsE,GAAG,2BAA2B,mCAAmC,6BAA6B,8BAA8B,mDAAmD,uDAAuD,4BAA4B,gHAAgH,yCAAyC,kEAAkE,0DAA0D,WAAW,EAAE,sEAAsE,OAAO,iNAAiN,8BAA8B,kBAAkB,sBAAsB,eAAe,mFAAmF,qBAAqB,WAAW,4CAA4C,uEAAuE,WAAW,gDAAgD,2OAA2O,WAAW,sDAAsD,iDAAiD,kDAAkD,WAAW,wDAAwD,qPAAqP,WAAW,OAAO,0CAA0C,4CAA4C,OAAO,iLAAiL,iBAAiB,2BAA2B,2FAA2F,sGAAsG,OAAO,wBAAwB,mDAAmD,gEAAgE,2CAA2C,qIAAqI,EAAE,WAAW,kCAAkC,OAAO,8BAA8B,oCAAoC,OAAO,6GAA6G,mBAAmB,iDAAiD,qEAAqE,OAAO,8IAA8I,YAAY,2DAA2D,iDAAiD,gDAAgD,YAAY,oBAAoB,WAAW,2EAA2E,OAAO,oIAAoI,UAAU,4FAA4F,+BAA+B,gEAAgE,YAAY,OAAO,0LAA0L,mDAAmD,gEAAgE,2CAA2C,2JAA2J,EAAE,WAAW,EAAE,OAAO,sHAAsH,EAAE,+DAA+D,mDAAmD,gEAAgE,2CAA2C,mKAAmK,EAAE,WAAW,EAAE,OAAO,4MAA4M,wCAAwC,gKAAgK,uCAAuC,6BAA6B,eAAe,IAAI,EAAE,WAAW,iDAAiD,gHAAgH,OAAO,eAAe,uBAAuB,WAAW,uBAAuB,4EAA4E,iFAAiF,8DAA8D,2BAA2B,eAAe,WAAW,OAAO,wJAAwJ,uDAAuD,iCAAiC,mCAAmC,oBAAoB,OAAO,oOAAoO,wBAAwB,yDAAyD,WAAW,gBAAgB,yDAAyD,WAAW,oCAAoC,OAAO,GAAG,+EAA+E,aAAa,mZAAmZ,+CAA+C,uIAAuI,kEAAkE,iBAAiB,qBAAqB,kJAAkJ,2DAA2D,WAAW,EAAE,6CAA6C,sPAAsP,EAAE,uEAAuE,OAAO,+IAA+I,6DAA6D,qCAAqC,0EAA0E,OAAO,+BAA+B,6DAA6D,oCAAoC,0EAA0E,4EAA4E,OAAO,0BAA0B,2DAA2D,qCAAqC,yEAAyE,OAAO,6BAA6B,yDAAyD,qCAAqC,kCAAkC,wEAAwE,OAAO,GAAG,iCAAiC,iHAAiH,+BAA+B,mCAAmC,iBAAiB,EAAE,2JAA2J,sGAAsG,kHAAkH,gDAAgD,6CAA6C,gBAAgB,mIAAmI,yFAAyF,iBAAiB,oJAAoJ,4FAA4F,oGAAoG,cAAc,wKAAwK,8HAA8H,6CAA6C,uGAAuG,2DAA2D,wCAAwC,EAAE,oBAAoB,kBAAkB,iBAAiB,cAAc,IAAI,6FAA6F,sDAAsD,gDAAgD,4DAA4D,2DAA2D,mEAAmE,4IAA4I,oBAAoB,kBAAkB,EAAE,+BAA+B,iBAAiB,cAAc,IAAI,6FAA6F,qHAAqH,IAAI,0FAA0F,mGAAmG,0EAA0E,wEAAwE,iBAAiB,EAAE,kBAAkB,gEAAgE,aAAa,EAAE,iBAAiB,cAAc,IAAI,8YAA8Y,yBAAyB,MAAM;;;;;;;;;;;;;;;;;;;ACAn+b;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;;;;AC1MY;AACtC;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,mIAAmI,qEAAmB,CAAC;AACvJ;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA,sDAAsD,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAyC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;UChI1B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACN2C;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,8DAAc,YAAY,uEAAuE;AACjH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://websandbox/./lib/frame.ts","webpack://websandbox/./lib/connection.ts","webpack://websandbox/./lib/websandbox.ts","webpack://websandbox/webpack/bootstrap","webpack://websandbox/webpack/runtime/compat get default export","webpack://websandbox/webpack/runtime/define property getters","webpack://websandbox/webpack/runtime/hasOwnProperty shorthand","webpack://websandbox/webpack/runtime/make namespace object","webpack://websandbox/./examples/simple/simple.js"],"sourcesContent":["module.exports = \"/******/ (() => { // webpackBootstrap\\n/******/ \\t\\\"use strict\\\";\\n/******/ \\tvar __webpack_modules__ = ({\\n\\n/***/ \\\"./lib/connection.ts\\\":\\n/*!***************************!*\\\\\\n  !*** ./lib/connection.ts ***!\\n  \\\\***************************/\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"TYPE_MESSAGE\\\": () => (/* binding */ TYPE_MESSAGE),\\n/* harmony export */   \\\"TYPE_RESPONSE\\\": () => (/* binding */ TYPE_RESPONSE),\\n/* harmony export */   \\\"TYPE_SET_INTERFACE\\\": () => (/* binding */ TYPE_SET_INTERFACE),\\n/* harmony export */   \\\"TYPE_SERVICE_MESSAGE\\\": () => (/* binding */ TYPE_SERVICE_MESSAGE),\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\nconst TYPE_MESSAGE = 'message';\\nconst TYPE_RESPONSE = 'response';\\nconst TYPE_SET_INTERFACE = 'set-interface';\\nconst TYPE_SERVICE_MESSAGE = 'service-message';\\n// @ts-expect-error this is IE11 obsolete check. It is not typed\\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\\nconst defaultOptions = {\\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\\n    //but base URL of iframe's src\\n    allowedSenderOrigin: undefined\\n};\\nclass Connection {\\n    constructor(postMessage, registerOnMessageListener, options = {}) {\\n        this.remote = {};\\n        this.serviceMethods = {};\\n        this.localApi = {};\\n        this.callbacks = {};\\n        this._resolveRemoteMethodsPromise = null;\\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\\n        //Random number between 0 and 100000\\n        this.incrementalID = Math.floor(Math.random() * 100000);\\n        this.postMessage = postMessage;\\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\\n            this._resolveRemoteMethodsPromise = resolve;\\n        });\\n        registerOnMessageListener((e) => this.onMessageListener(e));\\n    }\\n    /**\\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\\n       * @param e - onMessage event\\n       */\\n    onMessageListener(e) {\\n        const data = e.data;\\n        const { allowedSenderOrigin } = this.options;\\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\\n            return;\\n        }\\n        if (data.type === TYPE_RESPONSE) {\\n            this.popCallback(data.callId, data.success, data.result);\\n        }\\n        else if (data.type === TYPE_MESSAGE) {\\n            this\\n                .callLocalApi(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n        else if (data.type === TYPE_SET_INTERFACE) {\\n            this.setInterface(data.apiMethods);\\n            this.responseOtherSide(data.callId);\\n        }\\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\\n            this\\n                .callLocalServiceMethod(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n    }\\n    postMessageToOtherSide(dataToPost) {\\n        this.postMessage(dataToPost, '*');\\n    }\\n    /**\\n       * Sets remote interface methods\\n       * @param remote - hash with keys of remote API methods. Values is ignored\\n       */\\n    setInterface(remoteMethods) {\\n        var _a;\\n        this.remote = {};\\n        remoteMethods.forEach((key) => this.remote[key] = this.createMethodWrapper(key));\\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\\n    }\\n    setLocalApi(api) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                apiMethods: Object.keys(api),\\n                type: TYPE_SET_INTERFACE\\n            });\\n        }).then(() => this.localApi = api);\\n    }\\n    setServiceMethods(api) {\\n        this.serviceMethods = api;\\n    }\\n    /**\\n       * Calls local method\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>|string}\\n       */\\n    callLocalApi(methodName, args) {\\n        return Promise.resolve(this.localApi[methodName](...args));\\n    }\\n    /**\\n       * Calls local method registered as \\\"service method\\\"\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>}\\n       */\\n    callLocalServiceMethod(methodName, args) {\\n        if (!this.serviceMethods[methodName]) {\\n            throw new Error(`Serivce method ${methodName} is not registered`);\\n        }\\n        return Promise.resolve(this.serviceMethods[methodName](...args));\\n    }\\n    /**\\n       * Wraps remote method with callback storing code\\n       * @param methodName - method to wrap\\n       * @returns {Function} - function to call as remote API interface\\n       */\\n    createMethodWrapper(methodName) {\\n        return (...args) => {\\n            return this.callRemoteMethod(methodName, ...args);\\n        };\\n    }\\n    /**\\n       * Calls other side with arguments provided\\n       * @param id\\n       * @param methodName\\n       * @param args\\n       */\\n    callRemoteMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Calls remote service method\\n       * @param methodName\\n       * @param args\\n       * @returns {*}\\n       */\\n    callRemoteServiceMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_SERVICE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Respond to remote call\\n       * @param id - remote call ID\\n       * @param result - result to pass to calling function\\n       */\\n    responseOtherSide(id, result, success = true) {\\n        if (result instanceof Error) {\\n            // Error could be non-serializable, so we copy properties manually\\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\\n                acc[it] = result[it];\\n                return acc;\\n            }, {});\\n        }\\n        const doPost = () => this.postMessage({\\n            callId: id,\\n            type: TYPE_RESPONSE,\\n            success,\\n            result\\n        }, '*');\\n        try {\\n            doPost();\\n        }\\n        catch (err) {\\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\\n            if (err instanceof DOMException) {\\n                result = JSON.parse(JSON.stringify(result));\\n                doPost();\\n            }\\n        }\\n    }\\n    /*\\n       * Stores callbacks to call later when remote call will be answered\\n       */\\n    registerCallback(successCallback, failureCallback) {\\n        const id = (++this.incrementalID).toString();\\n        this.callbacks[id] = { successCallback, failureCallback };\\n        return id;\\n    }\\n    /**\\n       * Calls and delete stored callback\\n       * @param id - call id\\n       * @param success - was call successful\\n       * @param result - result of remote call\\n       */\\n    popCallback(id, success, result) {\\n        if (success) {\\n            this.callbacks[id].successCallback(result);\\n        }\\n        else {\\n            this.callbacks[id].failureCallback(result);\\n        }\\n        delete this.callbacks[id];\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Connection);\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/ts-loader/index.js??ruleSet[1].rules[0]!./lib/frame.ts\\\":\\n/*!*****************************************************************************!*\\\\\\n  !*** ./node_modules/ts-loader/index.js??ruleSet[1].rules[0]!./lib/frame.ts ***!\\n  \\\\*****************************************************************************/\\n/***/ ((module, __webpack_exports__, __webpack_require__) => {\\n\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connection */ \\\"./lib/connection.ts\\\");\\n/* module decorator */ module = __webpack_require__.hmd(module);\\n\\nclass Frame {\\n    constructor() {\\n        this.connection = new _connection__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](window.parent.postMessage.bind(window.parent), listener => {\\n            window.addEventListener('message', listener);\\n        });\\n        this.connection.setServiceMethods({\\n            runCode: (code) => this.runCode(code),\\n            importScript: (path) => this.importScript(path),\\n            injectStyle: (style) => this.injectStyle(style),\\n            importStyle: (path) => this.importStyle(path)\\n        });\\n        this.connection.callRemoteServiceMethod('iframeInitialized');\\n    }\\n    /**\\n       * Creates script tag with passed code and attaches it. Runs synchronous\\n       * @param code\\n       */\\n    runCode(code) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.innerHTML = code;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n    }\\n    importScript(scriptUrl) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.src = scriptUrl;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n        return new Promise(resolve => scriptTag.onload = () => resolve());\\n    }\\n    injectStyle(style) {\\n        const styleTag = document.createElement('style');\\n        styleTag.innerHTML = style;\\n        document.getElementsByTagName('head')[0].appendChild(styleTag);\\n    }\\n    importStyle(styleUrl) {\\n        const linkTag = document.createElement('link');\\n        linkTag.rel = 'stylesheet';\\n        linkTag.href = styleUrl;\\n        document.getElementsByTagName('head')[0].appendChild(linkTag);\\n    }\\n}\\nconst Websandbox = new Frame();\\n// @ts-expect-error exporting library to global namespace\\nwindow.Websandbox = window.Websandbox || Websandbox;\\nmodule.exports = Websandbox; // eslint-disable-line\\n\\n\\n/***/ })\\n\\n/******/ \\t});\\n/************************************************************************/\\n/******/ \\t// The module cache\\n/******/ \\tvar __webpack_module_cache__ = {};\\n/******/ \\t\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\t\\tif (cachedModule !== undefined) {\\n/******/ \\t\\t\\treturn cachedModule.exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t\\tid: moduleId,\\n/******/ \\t\\t\\tloaded: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/ \\t\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n/******/ \\t\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.loaded = true;\\n/******/ \\t\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t/* webpack/runtime/define property getters */\\n/******/ \\t(() => {\\n/******/ \\t\\t// define getter functions for harmony exports\\n/******/ \\t\\t__webpack_require__.d = (exports, definition) => {\\n/******/ \\t\\t\\tfor(var key in definition) {\\n/******/ \\t\\t\\t\\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n/******/ \\t\\t\\t\\t\\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\\n/******/ \\t\\t\\t\\t}\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/harmony module decorator */\\n/******/ \\t(() => {\\n/******/ \\t\\t__webpack_require__.hmd = (module) => {\\n/******/ \\t\\t\\tmodule = Object.create(module);\\n/******/ \\t\\t\\tif (!module.children) module.children = [];\\n/******/ \\t\\t\\tObject.defineProperty(module, 'exports', {\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tset: () => {\\n/******/ \\t\\t\\t\\t\\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\\n/******/ \\t\\t\\t\\t}\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t\\treturn module;\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/hasOwnProperty shorthand */\\n/******/ \\t(() => {\\n/******/ \\t\\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/make namespace object */\\n/******/ \\t(() => {\\n/******/ \\t\\t// define __esModule on exports\\n/******/ \\t\\t__webpack_require__.r = (exports) => {\\n/******/ \\t\\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t\\n/******/ \\t// startup\\n/******/ \\t// Load entry module and return exports\\n/******/ \\t// This entry module is referenced by other modules so it can't be inlined\\n/******/ \\tvar __webpack_exports__ = __webpack_require__(\\\"./node_modules/ts-loader/index.js??ruleSet[1].rules[0]!./lib/frame.ts\\\");\\n/******/ \\t\\n/******/ })()\\n;\\n//# sourceMappingURL=compile-loader-file-name.js.map\"","export const TYPE_MESSAGE = 'message';\nexport const TYPE_RESPONSE = 'response';\nexport const TYPE_SET_INTERFACE = 'set-interface';\nexport const TYPE_SERVICE_MESSAGE = 'service-message';\n// @ts-expect-error this is IE11 obsolete check. It is not typed\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\nconst defaultOptions = {\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\n    //but base URL of iframe's src\n    allowedSenderOrigin: undefined\n};\nclass Connection {\n    constructor(postMessage, registerOnMessageListener, options = {}) {\n        this.remote = {};\n        this.serviceMethods = {};\n        this.localApi = {};\n        this.callbacks = {};\n        this._resolveRemoteMethodsPromise = null;\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\n        //Random number between 0 and 100000\n        this.incrementalID = Math.floor(Math.random() * 100000);\n        this.postMessage = postMessage;\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\n            this._resolveRemoteMethodsPromise = resolve;\n        });\n        registerOnMessageListener((e) => this.onMessageListener(e));\n    }\n    /**\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\n       * @param e - onMessage event\n       */\n    onMessageListener(e) {\n        const data = e.data;\n        const { allowedSenderOrigin } = this.options;\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\n            return;\n        }\n        if (data.type === TYPE_RESPONSE) {\n            this.popCallback(data.callId, data.success, data.result);\n        }\n        else if (data.type === TYPE_MESSAGE) {\n            this\n                .callLocalApi(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n        else if (data.type === TYPE_SET_INTERFACE) {\n            this.setInterface(data.apiMethods);\n            this.responseOtherSide(data.callId);\n        }\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\n            this\n                .callLocalServiceMethod(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n    }\n    postMessageToOtherSide(dataToPost) {\n        this.postMessage(dataToPost, '*');\n    }\n    /**\n       * Sets remote interface methods\n       * @param remote - hash with keys of remote API methods. Values is ignored\n       */\n    setInterface(remoteMethods) {\n        var _a;\n        this.remote = {};\n        remoteMethods.forEach((key) => this.remote[key] = this.createMethodWrapper(key));\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    setLocalApi(api) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                apiMethods: Object.keys(api),\n                type: TYPE_SET_INTERFACE\n            });\n        }).then(() => this.localApi = api);\n    }\n    setServiceMethods(api) {\n        this.serviceMethods = api;\n    }\n    /**\n       * Calls local method\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>|string}\n       */\n    callLocalApi(methodName, args) {\n        return Promise.resolve(this.localApi[methodName](...args));\n    }\n    /**\n       * Calls local method registered as \"service method\"\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>}\n       */\n    callLocalServiceMethod(methodName, args) {\n        if (!this.serviceMethods[methodName]) {\n            throw new Error(`Serivce method ${methodName} is not registered`);\n        }\n        return Promise.resolve(this.serviceMethods[methodName](...args));\n    }\n    /**\n       * Wraps remote method with callback storing code\n       * @param methodName - method to wrap\n       * @returns {Function} - function to call as remote API interface\n       */\n    createMethodWrapper(methodName) {\n        return (...args) => {\n            return this.callRemoteMethod(methodName, ...args);\n        };\n    }\n    /**\n       * Calls other side with arguments provided\n       * @param id\n       * @param methodName\n       * @param args\n       */\n    callRemoteMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Calls remote service method\n       * @param methodName\n       * @param args\n       * @returns {*}\n       */\n    callRemoteServiceMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_SERVICE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Respond to remote call\n       * @param id - remote call ID\n       * @param result - result to pass to calling function\n       */\n    responseOtherSide(id, result, success = true) {\n        if (result instanceof Error) {\n            // Error could be non-serializable, so we copy properties manually\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\n                acc[it] = result[it];\n                return acc;\n            }, {});\n        }\n        const doPost = () => this.postMessage({\n            callId: id,\n            type: TYPE_RESPONSE,\n            success,\n            result\n        }, '*');\n        try {\n            doPost();\n        }\n        catch (err) {\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\n            if (err instanceof DOMException) {\n                result = JSON.parse(JSON.stringify(result));\n                doPost();\n            }\n        }\n    }\n    /*\n       * Stores callbacks to call later when remote call will be answered\n       */\n    registerCallback(successCallback, failureCallback) {\n        const id = (++this.incrementalID).toString();\n        this.callbacks[id] = { successCallback, failureCallback };\n        return id;\n    }\n    /**\n       * Calls and delete stored callback\n       * @param id - call id\n       * @param success - was call successful\n       * @param result - result of remote call\n       */\n    popCallback(id, success, result) {\n        if (success) {\n            this.callbacks[id].successCallback(result);\n        }\n        else {\n            this.callbacks[id].failureCallback(result);\n        }\n        delete this.callbacks[id];\n    }\n}\nexport default Connection;\n","import Connection from './connection';\n// @ts-expect-error loader-based input\nimport CompiledFrameScript from 'compile-code-loader!./frame.ts';\nexport const BaseOptions = {\n    frameContainer: 'body',\n    frameClassName: 'websandbox__frame',\n    frameSrc: null,\n    frameContent: `\n<!DOCTYPE html>\n<html>\n<head><meta charset=\"UTF-8\"></head>\n<body></body>\n</html>\n  `,\n    codeToRunBeforeInit: null,\n    initialStyles: null,\n    baseUrl: null,\n    allowPointerLock: false,\n    allowFullScreen: false,\n    sandboxAdditionalAttributes: ''\n};\nclass Websandbox {\n    /**\n     * {Constructor}\n     * @param localApi\n     * @param options\n     */\n    constructor(localApi, options) {\n        this.connection = null;\n        this.removeMessageListener = () => { };\n        this.options = options;\n        this.iframe = this.createIframe();\n        this.promise = new Promise(resolve => {\n            this.connection = new Connection(this.iframe.contentWindow.postMessage.bind(this.iframe.contentWindow), listener => {\n                const sourceCheckListener = (event) => {\n                    if (event.source !== this.iframe.contentWindow) {\n                        return;\n                    }\n                    return listener(event);\n                };\n                window.addEventListener('message', sourceCheckListener);\n                this.removeMessageListener = () => window.removeEventListener('message', sourceCheckListener);\n            }, { allowedSenderOrigin: 'null' });\n            this.connection.setServiceMethods({\n                iframeInitialized: () => {\n                    return this.connection\n                        .setLocalApi(localApi)\n                        .then(() => resolve(this));\n                }\n            });\n        });\n    }\n    /**\n     * Creates sandbox instancea\n     * @param localApi Api of this side. Will be available for sandboxed code as remoteApi\n     * @param options Options of created sandbox\n     */\n    static create(localApi, options = {}) {\n        return new Websandbox(localApi, Object.assign(BaseOptions, options));\n    }\n    _prepareFrameContent(options) {\n        var _a, _b;\n        let frameContent = (_b = (_a = options.frameContent) === null || _a === void 0 ? void 0 : _a.replace('</head>', `<script>${CompiledFrameScript}</script>\\n</head>`)) !== null && _b !== void 0 ? _b : '';\n        if (options.initialStyles) {\n            frameContent = frameContent\n                .replace('</head>', `<style>${options.initialStyles}</style>\\n</head>`);\n        }\n        if (options.baseUrl) {\n            frameContent = frameContent\n                .replace('<head>', `<head>\\n<base href=\"${options.baseUrl}\"/>`);\n        }\n        if (options.codeToRunBeforeInit) {\n            frameContent = frameContent\n                .replace('<head>', `<head>\\n<script>${options.codeToRunBeforeInit}</script>`);\n        }\n        return frameContent;\n    }\n    createIframe() {\n        var _a;\n        const containerSelector = this.options.frameContainer;\n        const container = typeof containerSelector === 'string'\n            ? document.querySelector(containerSelector)\n            : containerSelector;\n        if (!container) {\n            throw new Error('Websandbox: Cannot find container for sandbox ' + container);\n        }\n        const frame = document.createElement('iframe');\n        // @ts-expect-error typings error\n        frame.sandbox = `allow-scripts ${this.options.sandboxAdditionalAttributes}`;\n        frame.className = (_a = this.options.frameClassName) !== null && _a !== void 0 ? _a : '';\n        if (this.options.allowFullScreen) {\n            frame.allowFullscreen = true;\n        }\n        if (this.options.frameSrc) {\n            frame.src = this.options.frameSrc;\n            container.appendChild(frame);\n            return frame;\n        }\n        if (this.options.frameContent && this.options.frameContent.indexOf('<head>') < 0) {\n            throw new Error('Websandbox: iFrame content must have \"<head>\" tag.');\n        }\n        frame.setAttribute('srcdoc', this._prepareFrameContent(this.options));\n        container.appendChild(frame);\n        return frame;\n    }\n    destroy() {\n        this.iframe.remove();\n        this.removeMessageListener();\n    }\n    _runCode(code) {\n        return this.connection.callRemoteServiceMethod('runCode', code);\n    }\n    _runFunction(fn) {\n        return this._runCode(`(${fn.toString()})()`);\n    }\n    run(codeOrFunction) {\n        if (codeOrFunction.name) {\n            return this._runFunction(codeOrFunction);\n        }\n        return this._runCode(codeOrFunction);\n    }\n    importScript(path) {\n        return this.connection.callRemoteServiceMethod('importScript', path);\n    }\n    injectStyle(style) {\n        return this.connection.callRemoteServiceMethod('injectStyle', style);\n    }\n}\nexport default Websandbox;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import Sandbox from '../../lib/websandbox';\n\nvar localApi = {\n    testApiFn: function (message) {\n        console.log('Host function called from iframe with: ' + message);\n    }\n};\n\nconsole.log('>>>');\nconst sandbox = Sandbox.create(localApi, {frameContainer: '.iframe__container', frameClassName: 'simple__iframe'});\nsandbox.promise\n    .then(() => {\n        console.log('Sandbox is created. Trying to run code inside');\n\n        return sandbox.run(`\n            console.info(\"Sandboxed code initialized successfully\");\n            var title = document.createElement('h3');\n            title.innerHTML = \"Content is generated from the sandbox\";\n            document.body.appendChild(title);\n            Websandbox.connection.remote.testApiFn(\"some argument\");\n\n            Websandbox.connection.setLocalApi({\n                sandboxedMethod: function(message) {\n                    console.info('sandboxedMethod called successfully:', message);\n                    return 'this is sandboxedMethod result';\n                }\n            });\n        `);\n    })\n    .then(() => console.log('Code has been ran'))\n    .then(() => {\n        console.log('Calling sandboxedMethod...');\n        return sandbox.connection.remote.sandboxedMethod('hello from host');\n    })\n    .then(res => console.log('Call was successful:', res));\n\n\n"],"names":[],"sourceRoot":""}